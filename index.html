<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Concorrência em Banco de Dados</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .log-message {
            transition: all 0.3s ease-in-out;
            padding: 6px 10px;
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .log-message:first-child {
            transform: translateY(-5px);
            opacity: 1;
        }
        ol {
            list-style-type: decimal;
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .op-block {
            animation: slideIn 0.3s ease forwards;
            flex-shrink: 0; /* Impede que os blocos encolham */
        }
        .error-highlight {
            background-color: #fef2f2 !important; /* light red */
            border: 2px solid #ef4444; /* red-500 */
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <!-- Alerta de Deadlock -->
    <div id="deadlock-alert" class="hidden fixed top-5 left-1/2 -translate-x-1/2 bg-red-600 text-white py-3 px-6 rounded-lg shadow-xl text-center font-bold text-lg z-50 flex items-center gap-3 transition-all duration-500 opacity-0 transform -translate-y-20">
        <i class="fas fa-exclamation-triangle animate-bounce"></i>
        <span>DEADLOCK DETECTADO! Resolvendo...</span>
    </div>

    <div id="app" class="container mx-auto p-4 sm:p-6 lg:p-8">

        <!-- Cabeçalho -->
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-slate-900">Simulador Web de Concorrência</h1>
            <p class="text-md sm:text-lg text-slate-600 mt-2">Entendendo os Problemas Clássicos de Transações de BD</p>
        </header>

        <!-- Seletor de Modo -->
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 justify-center items-center mb-6 bg-slate-200 p-2 rounded-xl max-w-6xl mx-auto gap-2 text-sm sm:text-base">
            <button data-mode="LOCKING" class="mode-btn px-4 py-2 text-center font-semibold rounded-lg transition-colors duration-300">
                <i class="fas fa-lock mr-2"></i>Deadlock
            </button>
            <button data-mode="LOST_UPDATE" class="mode-btn px-4 py-2 text-center font-semibold rounded-lg transition-colors duration-300">
                <i class="fas fa-edit mr-2"></i>Lost Update
            </button>
             <button data-mode="DIRTY_READ" class="mode-btn px-4 py-2 text-center font-semibold rounded-lg transition-colors duration-300">
                <i class="fas fa-eye-slash mr-2"></i>Dirty Read
            </button>
            <button data-mode="UNREPEATABLE_READ" class="mode-btn px-4 py-2 text-center font-semibold rounded-lg transition-colors duration-300">
                <i class="fas fa-sync-alt mr-2"></i>Unrepeatable Read
            </button>
            <button data-mode="PHANTOM_READ" class="mode-btn px-4 py-2 text-center font-semibold rounded-lg transition-colors duration-300">
                <i class="fas fa-ghost mr-2"></i>Phantom Read
            </button>
        </div>


        <!-- Painel Explicativo -->
        <div id="explanation-panel" class="bg-white p-6 rounded-lg shadow-md mb-8 transition-all duration-500">
            <!-- Conteúdo dinâmico aqui -->
        </div>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Coluna Principal (Simulação) -->
            <div class="lg:col-span-2 space-y-8">
                
                <!-- Dados do Banco -->
                <section>
                    <h2 class="text-2xl font-bold mb-4 border-b-2 border-slate-300 pb-2">
                        <i class="fas fa-database mr-2 text-blue-600"></i>Dados do Banco
                    </h2>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                        <div id="accounts-container" class="grid grid-cols-1 gap-6">
                           <!-- Contas geradas via JS -->
                        </div>
                        <div id="query-container" class="hidden">
                            <!-- Container para a simulação de query -->
                        </div>
                    </div>
                </section>

                 <!-- Pipeline de Operações -->
                <section id="pipeline-section" class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4 border-b-2 border-slate-300 pb-2">
                        <i class="fas fa-chart-bar mr-2 text-purple-600"></i>Pipeline de Operações
                    </h2>
                    <div class="space-y-4">
                        <!-- Pipeline T1 -->
                        <div class="flex items-center gap-4">
                            <div class="font-bold text-lg text-white bg-blue-500 w-12 h-12 flex items-center justify-center rounded-full flex-shrink-0">T1</div>
                            <div class="w-full bg-slate-100 rounded-lg p-2 overflow-x-auto relative">
                                <div id="t1-arrow" class="hidden absolute -top-4 text-purple-600 text-2xl transition-all duration-300 ease-in-out">
                                    <i class="fas fa-chevron-down animate-bounce"></i>
                                </div>
                                <div id="t1-pipeline" class="flex items-center gap-2 h-16">
                                    <!-- Blocos de operação T1 -->
                                </div>
                            </div>
                        </div>
                        <!-- Pipeline T2 -->
                        <div class="flex items-center gap-4">
                           <div class="font-bold text-lg text-white bg-green-500 w-12 h-12 flex items-center justify-center rounded-full flex-shrink-0">T2</div>
                           <div class="w-full bg-slate-100 rounded-lg p-2 overflow-x-auto relative">
                                <div id="t2-arrow" class="hidden absolute -top-4 text-purple-600 text-2xl transition-all duration-300 ease-in-out">
                                    <i class="fas fa-chevron-down animate-bounce"></i>
                                </div>
                                <div id="t2-pipeline" class="flex items-center gap-2 h-16">
                                    <!-- Blocos de operação T2 -->
                                </div>
                           </div>
                        </div>
                    </div>
                </section>


                <!-- Painel de Controle de Transferência -->
                 <section class="bg-white p-6 rounded-lg shadow-md">
                     <h3 class="text-xl font-bold mb-4 text-slate-700">Controle de Operações</h3>
                     <div class="flex items-center space-x-4">
                         <label for="transfer-amount" class="font-semibold">Valor da Operação (R$):</label>
                         <input type="text" id="transfer-amount" value="100" class="w-32 p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                         <button id="reset-button" class="ml-auto bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                             <i class="fas fa-sync-alt mr-2"></i>Resetar
                         </button>
                     </div>
                 </section>

                <!-- Sessões de Clientes -->
                <section class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div id="t1-container" class="bg-white p-6 rounded-lg shadow-md transition-colors duration-300"></div>
                    <div id="t2-container" class="bg-white p-6 rounded-lg shadow-md transition-colors duration-300"></div>
                </section>
            </div>

            <!-- Coluna do Log -->
            <aside class="lg:col-span-1 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-bold mb-4 border-b-2 border-slate-300 pb-2">
                    <i class="fas fa-stream mr-2 text-green-600"></i>Log de Eventos
                </h2>
                <div id="log-container" class="h-96 overflow-y-auto bg-slate-50 p-3 rounded-md text-sm">
                    <!-- Mensagens do log aqui -->
                </div>
            </aside>
        </main>

        <footer class="text-center mt-8 py-4">
            <p class="text-slate-500 text-sm">Criado por Prof. Gabriel Duarte</p>
        </footer>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- ENUMS e CONSTANTES ---
        const LockType = { SHARED: 'SHARED', EXCLUSIVE: 'EXCLUSIVE' };
        const T_State = { IDLE: 'IDLE', ACTIVE: 'ACTIVE', WAITING: 'WAITING', COMMITTED: 'COMMITTED', ABORTED: 'ABORTED' };
        const SimMode = { 
            LOCKING: 'LOCKING', 
            LOST_UPDATE: 'LOST_UPDATE',
            DIRTY_READ: 'DIRTY_READ',
            UNREPEATABLE_READ: 'UNREPEATABLE_READ',
            PHANTOM_READ: 'PHANTOM_READ'
        };

        // --- ESTADO DA APLICAÇÃO ---
        let state = {
            simMode: SimMode.LOCKING,
            initialValues: { 'Conta C': 1000.00, 'Conta P': 400.00 }, // Conta P < 450 para Phantom Read
            dataItems: {},
            transactions: [],
            logMessages: [],
            deadlockCheckInterval: null,
            mainUpdateInterval: null
        };

        // --- CLASSES DA SIMULAÇÃO (LÓGICA) ---
        class Transaction {
            constructor(name, color) {
                this.name = name;
                this.color = color;
                this.state = T_State.IDLE;
                this.locksHeld = {}; // { itemName: lockType }
                this.waitingFor = null; // { item, lockType }
                this.pendingOp = null;
                this.history = []; // Para o pipeline
                this.localValue = null; 
                this.hasError = false; // Para destacar painel com erro
            }
            reset() {
                this.state = T_State.IDLE;
                this.locksHeld = {};
                this.waitingFor = null;
                this.pendingOp = null;
                this.history = [];
                this.localValue = null;
                this.hasError = false;
            }
        }
        
        // --- FUNÇÕES DE INICIALIZAÇÃO ---
        function init() {
            for (const name in state.initialValues) {
                state.dataItems[name] = {
                    name,
                    value: state.initialValues[name],
                    tempValue: state.initialValues[name],
                    lockType: null,
                    holders: new Set()
                };
            }
            state.transactions = [new Transaction('T1', 'blue'), new Transaction('T2', 'green')];
            
            setupEventListeners();
            log("Simulador iniciado. Escolha um modo de simulação.", "purple");
            setSimMode(SimMode.LOCKING); 
            renderAll();
        }

        function setupEventListeners() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => setSimMode(btn.dataset.mode));
            });
            document.getElementById('reset-button').addEventListener('click', resetSimulation);
        }

        // --- LÓGICA DE MODO DE SIMULAÇÃO ---
        const explanations = {
            [SimMode.LOCKING]: {
                title: "Problema 1: Deadlock",
                problem: `
                    <p class="mb-4">O <strong>Deadlock</strong> (impasse) acontece quando duas ou mais transações ficam presas numa espera circular: T1 espera por um recurso que T2 possui, e T2 espera por um recurso que T1 possui. Nenhuma pode continuar.</p>
                    <h4 class="font-bold text-slate-700 mb-2">Como Criar um Deadlock (Passo a Passo):</h4>
                    <ol>
                        <li><strong>Inicie as Transações:</strong> Clique em "Iniciar" para T1 e depois para T2.</li>
                        <li><strong>Inicie a Transferência de T1:</strong> Clique em <strong>"Transf. C -> P"</strong>. T1 vai adquirir um lock na 'Conta C'.</li>
                        <li><strong>Inicie a Transferência de T2:</strong> Clique em <strong>"Transf. P -> C"</strong>. T2 vai adquirir um lock na 'Conta P'.</li>
                        <li><strong>DEADLOCK!</strong> Agora, o sistema tentará automaticamente continuar as transferências. T1 precisa da 'Conta P' (bloqueada por T2) e T2 precisa da 'Conta C' (bloqueada por T1). Aguarde o alerta!</li>
                    </ol>
                `,
                solution: `
                     <h4 class="font-bold text-slate-700 mb-2">Como os SGBDs Solucionam:</h4>
                     <p class="mb-2">Sistemas de Gerenciamento de Banco de Dados (SGBDs) usam duas abordagens principais:</p>
                     <ul class="list-disc pl-5 space-y-2 text-sm">
                         <li><strong>Detecção e Resolução (Mais Comum):</strong> O SGBD mantém um grafo de esperas (<em>waits-for graph</em>), exatamente como este simulador. Periodicamente, ele verifica se existem ciclos nesse grafo. Ao encontrar um ciclo (um deadlock), ele escolhe uma das transações como "vítima", a aborta (fazendo um rollback) e libera seus locks, permitindo que as outras prossigam.</li>
                         <li><strong>Prevenção:</strong> Alguns sistemas tentam prevenir o deadlock. Uma técnica comum é a <strong>ordenação de locks</strong>, onde todas as transações devem solicitar locks sobre os recursos (tabelas, linhas) sempre na mesma ordem. Isso torna um ciclo de espera matematicamente impossível.</li>
                     </ul>
                `
            },
            [SimMode.LOST_UPDATE]: {
                title: "Problema 2: Atualização Perdida",
                problem: `
                    <p class="mb-4">Ocorre quando duas transações leem o mesmo dado e, em seguida, o atualizam. A segunda atualização sobrescreve a primeira, fazendo com que a primeira atualização seja "perdida".</p>
                    <h4 class="font-bold text-slate-700 mb-2">Como Causar uma Atualização Perdida:</h4>
                     <ol>
                        <li><strong>Inicie as Transações:</strong> Clique em "Iniciar" para T1 e T2.</li>
                        <li><strong>Leitura Concorrente:</strong> Clique em <strong>"Ler Saldo C"</strong> para T1, e depois para T2. Ambas leram o mesmo valor inicial (ex: R$ 1000).</li>
                        <li><strong>Depósitos Concorrentes:</strong> Defina um valor (ex: R$ 100). Clique em <strong>"Depositar em C"</strong> para T1. O saldo será 1100. Agora, clique em <strong>"Depositar em C"</strong> para T2.</li>
                        <li><strong>ERRO!</strong> T2 também calcula 1000 + 100 = 1100. O depósito de T1 foi "perdido". O saldo correto deveria ser R$ 1200.</li>
                    </ol>
                `,
                solution: `
                    <h4 class="font-bold text-slate-700 mb-2">Como os SGBDs Solucionam:</h4>
                     <p class="mb-2">A solução padrão é o uso de <strong>locks pessimistas</strong>. O primeiro <code>UPDATE</code> (ou um <code>SELECT ... FOR UPDATE</code>) em um dado coloca um <strong>lock de escrita (Exclusivo)</strong> sobre ele.</p>
                     <ul class="list-disc pl-5 space-y-2 text-sm">
                         <li>Quando T1 executa o <code>UPDATE</code>, ela bloqueia a 'Conta C'.</li>
                         <li>Quando T2 tenta executar o seu <code>UPDATE</code>, ela é forçada a <strong>esperar</strong> até que T1 finalize (com um commit ou abort) e libere o lock.</li>
                         <li>Só então T2 pode prosseguir, lendo o novo valor (R$ 1100) e aplicando sua atualização, resultando no valor correto de R$ 1200.</li>
                     </ul>
                `
            },
            [SimMode.DIRTY_READ]: {
                title: "Problema 3: Leitura Suja",
                problem: `
                     <p class="mb-4">Ocorre quando uma transação (T2) lê dados que foram modificados por outra transação (T1) que ainda <strong>não foi confirmada</strong> (commit). Se T1 for revertida (abort), T2 terá lido dados "sujos" que nunca existiram oficialmente.</p>
                     <h4 class="font-bold text-slate-700 mb-2">Como Causar uma Leitura Suja:</h4>
                     <ol>
                         <li><strong>Inicie T1:</strong> Clique em "Iniciar" para T1.</li>
                         <li><strong>T1 Altera Dado:</strong> Clique em <strong>"Update Saldo C (sem commit)"</strong> para T1. O valor na tela mudará para <strong class="text-orange-500">laranja</strong>, indicando um dado "sujo".</li>
                         <li><strong>Inicie T2 e Leia o Dado Sujo:</strong> Inicie T2 e clique em <strong>"Ler Saldo C"</strong>. T2 lerá o valor alterado, mas não confirmado.</li>
                         <li><strong>T1 Desfaz a Operação:</strong> Clique em <strong>"Abort"</strong> para T1. A alteração é desfeita.</li>
                         <li><strong>ERRO!</strong> O painel de T2 ficará <strong class="text-red-500">vermelho</strong>, pois agora ela opera com base em um valor inválido.</li>
                     </ol>
                `,
                solution: `
                    <h4 class="font-bold text-slate-700 mb-2">Como os SGBDs Solucionam:</h4>
                     <p class="mb-2">Este problema é resolvido pelo nível de isolamento padrão na maioria dos SGBDs: <strong><code>READ COMMITTED</code></strong>.</p>
                     <p class="text-sm">Neste nível, uma transação <strong>não consegue enxergar</strong> as alterações feitas por outras transações que ainda não foram commitadas. Em um SGBD real, quando T2 tentasse ler a 'Conta C' (que T1 modificou), uma de duas coisas aconteceria:</p>
                     <ul class="list-disc pl-5 space-y-2 text-sm">
                         <li>O SGBD faria T2 <strong>esperar</strong> até T1 dar commit ou abort.</li>
                         <li>Ou, mais comumente, o SGBD manteria uma <strong>versão antiga</strong> do dado e a entregaria para T2, garantindo que ela só veja dados confirmados (consistentes).</li>
                     </ul>
                `
            },
            [SimMode.UNREPEATABLE_READ]: {
                title: "Problema 4: Leitura Não-Repetível",
                problem: `
                     <p class="mb-4">Ocorre quando uma transação (T1) lê o mesmo dado duas vezes, mas obtém resultados diferentes porque outra transação (T2) alterou e confirmou esse dado entre as duas leituras de T1.</p>
                     <h4 class="font-bold text-slate-700 mb-2">Como Causar uma Leitura Não-Repetível:</h4>
                     <ol>
                         <li><strong>Inicie T1 e T2.</strong></li>
                         <li><strong>Primeira Leitura de T1:</strong> Clique em <strong>"1ª Leitura Saldo C"</strong> para T1. Anote o valor lido.</li>
                         <li><strong>T2 Altera e Confirma:</strong> Clique em <strong>"Update & Commit Saldo C"</strong> para T2. O valor da conta é alterado permanentemente.</li>
                         <li><strong>Segunda Leitura de T1:</strong> Clique em <strong>"2ª Leitura Saldo C"</strong> para T1.</li>
                         <li><strong>ERRO!</strong> T1 leu dois valores diferentes para o mesmo dado. O painel de T1 ficará <strong class="text-red-500">vermelho</strong> para indicar a inconsistência.</li>
                     </ol>
                `,
                solution: `
                    <h4 class="font-bold text-slate-700 mb-2">Como os SGBDs Solucionam:</h4>
                     <p class="mb-2">Este problema é resolvido por um nível de isolamento mais alto: <strong><code>REPEATABLE READ</code></strong>.</p>
                     <p class="text-sm">Quando T1 executa sua primeira leitura, o SGBD coloca um <strong>lock de leitura (Compartilhado)</strong> na 'Conta C'. Diferente do <code>READ COMMITTED</code>, esse lock é <strong>mantido até o final da transação T1</strong>.</p>
                     <ul class="list-disc pl-5 space-y-2 text-sm">
                         <li>Quando T2 tenta executar seu <code>UPDATE</code>, ela precisa de um lock de escrita (Exclusivo), que é incompatível com o lock de leitura de T1.</li>
                         <li>Portanto, T2 é forçada a <strong>esperar</strong> até que T1 termine. Isso garante que T1 sempre veja a mesma "fotografia" dos dados do início ao fim de sua execução.</li>
                     </ul>
                `
            },
            [SimMode.PHANTOM_READ]: {
                 title: "Problema 5: Leitura Fantasma",
                 problem: `
                     <p class="mb-4">Ocorre quando uma transação (T1) executa uma consulta que retorna um <strong>conjunto de linhas</strong> duas vezes. Entre as duas execuções, outra transação (T2) insere uma nova linha que satisfaz o critério da consulta de T1.</p>
                     <h4 class="font-bold text-slate-700 mb-2">Como Causar uma Leitura Fantasma:</h4>
                      <ol>
                         <li><strong>Inicie T1 e T2.</strong></li>
                         <li><strong>1ª Contagem de T1:</strong> Clique em <strong>"1ª Contagem Clientes Ricos"</strong> para T1. Ele contará quantos clientes têm saldo > R$ 450.</li>
                         <li><strong>T2 Cria um Novo "Rico":</strong> Clique em <strong>"Tornar Conta P 'Rica' & Commit"</strong> para T2. Isso aumenta o saldo da Conta P, fazendo-a corresponder ao critério.</li>
                         <li><strong>2ª Contagem de T1:</strong> Clique em <strong>"2ª Contagem Clientes Ricos"</strong> para T1.</li>
                         <li><strong>ERRO!</strong> T1 agora encontra um resultado diferente. Um cliente "fantasma" apareceu, quebrando a consistência da visão de T1.</li>
                     </ol>
                 `,
                 solution: `
                    <h4 class="font-bold text-slate-700 mb-2">Como os SGBDs Solucionam:</h4>
                     <p class="mb-2">Este problema é o mais difícil de resolver e exige o nível de isolamento mais alto: <strong><code>SERIALIZABLE</code></strong>.</p>
                     <p class="text-sm">Neste nível, o SGBD não apenas bloqueia as linhas que são lidas, mas também utiliza uma técnica chamada <strong>travamento de intervalo de chave (key-range locking)</strong>. Ele bloqueia o "intervalo" definido pela cláusula <code>WHERE</code>.</p>
                     <ul class="list-disc pl-5 space-y-2 text-sm">
                         <li>Quando T1 executa a consulta <code>WHERE saldo > 450</code>, o SGBD bloqueia esse intervalo.</li>
                         <li>Quando T2 tenta inserir (ou atualizar) uma nova linha que cairia nesse intervalo (ex: alterar o saldo para R$ 600), ela é impedida e forçada a <strong>esperar</strong>.</li>
                         <li>Isso garante que nenhuma linha "fantasma" possa aparecer ou desaparecer enquanto T1 estiver ativa, fazendo com que a execução seja equivalente a uma execução serial.</li>
                     </ul>
                 `
            }
        };

        function setSimMode(mode) {
            state.simMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                const isActive = btn.dataset.mode === mode;
                btn.classList.toggle('bg-blue-600', isActive && mode === 'LOCKING');
                btn.classList.toggle('bg-red-600', isActive && (mode !== 'LOCKING'));
                btn.classList.toggle('text-white', isActive);
            });
            
            const panel = document.getElementById('explanation-panel');
            const explanation = explanations[mode];
            panel.innerHTML = `
                <div class="flex border-b border-slate-200 mb-4">
                    <button data-tab="problem" class="tab-btn py-2 px-4 font-semibold border-b-2">O Problema</button>
                    <button data-tab="solution" class="tab-btn py-2 px-4 font-semibold border-b-2">A Solução do SGBD</button>
                </div>
                <div id="problem-content" class="tab-content text-slate-600">
                     <h3 class="text-xl font-bold mb-2 text-slate-800">${explanation.title}</h3>
                     ${explanation.problem}
                </div>
                <div id="solution-content" class="hidden tab-content text-slate-600">
                     <h3 class="text-xl font-bold mb-2 text-slate-800">Solução para ${explanation.title.split(':')[1]}</h3>
                     ${explanation.solution}
                </div>
            `;

            clearInterval(state.deadlockCheckInterval);
            clearInterval(state.mainUpdateInterval);

            if(mode === SimMode.LOCKING) {
                state.mainUpdateInterval = setInterval(update, 500);
                state.deadlockCheckInterval = setInterval(detectAndResolveDeadlock, 2000);
            } else {
                state.deadlockCheckInterval = null;
                state.mainUpdateInterval = null;
            }

            panel.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tab = e.currentTarget.dataset.tab;
                    panel.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                    panel.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('text-blue-600', 'border-blue-600'));
                    
                    document.getElementById(`${tab}-content`).classList.remove('hidden');
                    e.currentTarget.classList.add('text-blue-600', 'border-blue-600');
                });
            });
            panel.querySelector('[data-tab="problem"]').click();

            resetSimulation(false);
        }

        // --- FUNÇÕES DE RENDERIZAÇÃO ---
        function renderAll() {
            renderAccountsAndQuery();
            renderTransactionPanels();
            renderPipelines();
            renderLog();
        }

        function renderAccountsAndQuery() {
            const accountsContainer = document.getElementById('accounts-container');
            const queryContainer = document.getElementById('query-container');
            accountsContainer.innerHTML = '';
            
            const isPhantomMode = state.simMode === SimMode.PHANTOM_READ;
            queryContainer.classList.toggle('hidden', !isPhantomMode);
            accountsContainer.classList.toggle('sm:grid-cols-2', !isPhantomMode);


            for (const name in state.dataItems) {
                const item = state.dataItems[name];
                let lockInfo = '';
                if (state.simMode === SimMode.LOCKING && item.lockType) {
                    const holders = Array.from(item.holders).map(t => t.name).join(',');
                    lockInfo = `<div class="absolute top-2 right-2 text-xs font-bold text-red-600 bg-red-100 px-2 py-1 rounded-full">
                        <i class="fas fa-lock"></i> ${item.lockType.slice(0,1)} por ${holders}
                    </div>`;
                }
                const accountEl = document.createElement('div');
                accountEl.className = 'bg-slate-50 p-6 rounded-lg shadow-inner relative';
                
                const displayValue = (state.simMode === SimMode.DIRTY_READ && item.value !== item.tempValue) ? item.tempValue : item.value;
                const valueClass = (displayValue !== item.value) ? 'text-orange-500' : 'text-blue-700';

                accountEl.innerHTML = `
                    <h3 class="text-xl font-bold text-slate-800">${item.name}</h3>
                    <p class="text-3xl font-light ${valueClass} mt-2">R$ ${displayValue.toFixed(2)}</p>
                    ${lockInfo}
                `;
                accountsContainer.appendChild(accountEl);
            }

            if (isPhantomMode) {
                 const richClientsCount = Object.values(state.dataItems).filter(item => item.value > 450).length;
                 queryContainer.innerHTML = `
                    <div class="bg-slate-50 p-6 rounded-lg shadow-inner h-full">
                         <h3 class="text-xl font-bold text-slate-800">Consulta de Clientes Ricos</h3>
                         <p class="text-sm text-slate-500 italic">SELECT COUNT(*) WHERE saldo > 450</p>
                         <p class="text-3xl font-light text-purple-700 mt-2">${richClientsCount} <span class="text-lg">clientes</span></p>
                    </div>
                 `;
            }
        }

        function renderTransactionPanels() {
            state.transactions.forEach(t => {
                const container = document.getElementById(`${t.name.toLowerCase()}-container`);
                container.classList.toggle('error-highlight', t.hasError);

                const stateMap = {
                    [T_State.IDLE]: { text: 'Inativa', color: 'text-slate-500' },
                    [T_State.ACTIVE]: { text: 'Ativa', color: 'text-green-600' },
                    [T_State.WAITING]: { text: 'Aguardando Lock', color: 'text-orange-500' },
                    [T_State.COMMITTED]: { text: 'Finalizada', color: 'text-blue-700' },
                    [T_State.ABORTED]: { text: 'Cancelada', color: 'text-red-700' },
                };

                let localValueInfo = '';
                if(t.localValue !== null) {
                    const label = (state.simMode === SimMode.PHANTOM_READ) ? 'Contagem local' : 'Valor lido localmente';
                    const unit = (state.simMode === SimMode.PHANTOM_READ) ? '' : 'R$ ';
                    localValueInfo = `<div class="text-sm text-slate-500 mt-1">${label}: ${unit}${t.localValue.toFixed(0)}</div>`;
                }

                let errorInfo = '';
                if (t.hasError) {
                    errorInfo = `<div class="mt-2 text-sm font-bold text-red-600 p-2 bg-red-50 rounded-lg">
                                    <i class="fas fa-exclamation-circle mr-2"></i>Esta transação está inconsistente!
                                 </div>`;
                }

                container.innerHTML = `
                    <h3 class="text-xl font-bold text-${t.color}-600">Sessão Cliente ${t.name}</h3>
                    <p class="font-semibold mt-2">Estado: <span class="font-bold ${stateMap[t.state].color}">${stateMap[t.state].text}</span></p>
                    ${localValueInfo}
                    ${errorInfo}
                    <div class="mt-4 space-y-2">
                        ${generateButtons(t)}
                    </div>
                `;
            });
            state.transactions.forEach(t => {
                 document.querySelectorAll(`[data-t-name="${t.name}"]`).forEach(btn => {
                    btn.addEventListener('click', (e) => handleButtonClick(e.currentTarget.dataset));
                 });
            });
            updateButtonStates();
        }

        function generateButtons(t) {
            let buttons = `
                <div class="flex space-x-2">
                    <button data-t-name="${t.name}" data-action="start" class="w-full bg-${t.color}-500 hover:bg-${t.color}-600 btn">Iniciar</button>
                    <button data-t-name="${t.name}" data-action="commit" class="w-full bg-green-500 hover:bg-green-600 btn">Commit</button>
                    <button data-t-name="${t.name}" data-action="abort" class="w-full bg-red-500 hover:bg-red-600 btn">Abort</button>
                </div>`;

            switch(state.simMode) {
                case SimMode.LOCKING:
                    const transferLabel = t.name === 'T1' ? 'Transf. C -> P' : 'Transf. P -> C';
                    buttons += `<button data-t-name="${t.name}" data-action="transfer" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">${transferLabel}</button>`;
                    break;
                case SimMode.LOST_UPDATE:
                     buttons += `<button data-t-name="${t.name}" data-action="read" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Ler Saldo C</button>`;
                     buttons += `<button data-t-name="${t.name}" data-action="deposit" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Depositar em C</button>`;
                    break;
                case SimMode.DIRTY_READ:
                    if (t.name === 'T1') {
                        buttons += `<button data-t-name="${t.name}" data-action="update_no_commit" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Update Saldo C (sem commit)</button>`;
                    } else {
                        buttons += `<button data-t-name="${t.name}" data-action="read" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Ler Saldo C</button>`;
                    }
                    break;
                case SimMode.UNREPEATABLE_READ:
                     if (t.name === 'T1') {
                        buttons += `<button data-t-name="${t.name}" data-action="read1" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">1ª Leitura Saldo C</button>`;
                        buttons += `<button data-t-name="${t.name}" data-action="read2" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">2ª Leitura Saldo C</button>`;
                    } else {
                        buttons += `<button data-t-name="${t.name}" data-action="update_commit" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Update & Commit Saldo C</button>`;
                    }
                    break;
                case SimMode.PHANTOM_READ:
                    if (t.name === 'T1') {
                        buttons += `<button data-t-name="${t.name}" data-action="count1" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">1ª Contagem Clientes Ricos</button>`;
                        buttons += `<button data-t-name="${t.name}" data-action="count2" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">2ª Contagem Clientes Ricos</button>`;
                    } else {
                        buttons += `<button data-t-name="${t.name}" data-action="make_rich_commit" class="w-full bg-${t.color}-200 text-${t.color}-800 hover:bg-${t.color}-300 btn-secondary">Tornar Conta P 'Rica' & Commit</button>`;
                    }
                    break;
            }
            
            return buttons.replaceAll('btn"', 'btn text-white font-bold py-2 px-4 rounded-lg shadow disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"');
        }

        function updateButtonStates() {
             state.transactions.forEach(t => {
                const isActive = t.state === T_State.ACTIVE || t.state === T_State.WAITING;
                const canOperate = t.state === T_State.ACTIVE && !t.pendingOp;

                if (t.hasError) {
                    document.querySelectorAll(`[data-t-name="${t.name}"] button`).forEach(btn => btn.disabled = true);
                    return;
                }
                
                document.querySelector(`[data-t-name="${t.name}"][data-action="start"]`).disabled = isActive;
                document.querySelector(`[data-t-name="${t.name}"][data-action="commit"]`).disabled = !isActive;
                document.querySelector(`[data-t-name="${t.name}"][data-action="abort"]`).disabled = !isActive;
                
                const actions = ['transfer', 'read', 'deposit', 'update_no_commit', 'read1', 'read2', 'update_commit', 'count1', 'count2', 'make_rich_commit'];
                actions.forEach(action => {
                    const btn = document.querySelector(`[data-t-name="${t.name}"][data-action="${action}"]`);
                    if(btn) btn.disabled = !canOperate;
                });
            });
        }
        
        function renderLog() {
            const container = document.getElementById('log-container');
            container.innerHTML = state.logMessages.map(msg => {
                const colorMap = {
                    black: 'bg-slate-200 text-slate-800',
                    green: 'bg-green-100 text-green-800',
                    red: 'bg-red-100 text-red-800',
                    orange: 'bg-orange-100 text-orange-800',
                    blue: 'bg-blue-100 text-blue-800',
                    purple: 'bg-purple-100 text-purple-800',
                };
                return `<div class="log-message ${colorMap[msg.color] || colorMap.black}">${msg.text}</div>`;
            }).join('');
        }

        function renderPipelines() {
            state.transactions.forEach(t => {
                const container = document.getElementById(`${t.name.toLowerCase()}-pipeline`);
                let pipelineHTML = "";
                const history = t.history;

                history.forEach((op, index) => {
                    const opMap = {
                        START: { icon: 'fa-play', text: 'Start', color: 'bg-gray-400' },
                        READ: { icon: 'fa-eye', text: `Read(${op.details})`, color: 'bg-blue-400' },
                        WRITE: { icon: 'fa-pencil-alt', text: `Write(${op.details})`, color: 'bg-yellow-500' },
                        UPDATE: { icon: 'fa-edit', text: `Update(${op.details})`, color: 'bg-yellow-500' },
                        QUERY: { icon: 'fa-search', text: `Count(${op.details})`, color: 'bg-purple-400' },
                        LOCK: { icon: 'fa-lock', text: `Lock(${op.details})`, color: 'bg-indigo-500' },
                        WAIT: { icon: 'fa-clock', text: `Wait(${op.details})`, color: 'bg-orange-500' },
                        COMMIT: { icon: 'fa-check', text: 'Commit', color: 'bg-green-500' },
                        ABORT: { icon: 'fa-times', text: 'Abort', color: 'bg-red-500' },
                    };
                    const opInfo = opMap[op.type] || { icon: 'fa-question', text: '?', color: 'bg-gray-300' };

                    pipelineHTML += `
                        <div class="op-block flex flex-col items-center justify-center text-white p-2 rounded-lg shadow-md w-24 h-14 ${opInfo.color}">
                            <i class="fas ${opInfo.icon} text-lg"></i>
                            <span class="text-xs font-semibold mt-1">${opInfo.text}</span>
                        </div>
                    `;
                    
                    if (index < history.length - 1) {
                         pipelineHTML += `<div class="text-2xl text-slate-400 flex-shrink-0"><i class="fas fa-long-arrow-alt-right"></i></div>`;
                    }
                });
                
                container.innerHTML = pipelineHTML;
                container.scrollLeft = container.scrollWidth;
            });
            renderPipelineArrows();
        }

        function renderPipelineArrows() {
             state.transactions.forEach(t => {
                const arrowEl = document.getElementById(`${t.name.toLowerCase()}-arrow`);
                const pipelineEl = document.getElementById(`${t.name.toLowerCase()}-pipeline`);
                const lastBlock = pipelineEl.lastElementChild;

                if (t.state === T_State.ACTIVE && lastBlock) {
                     arrowEl.classList.remove('hidden');
                    const arrowOffset = lastBlock.offsetLeft + lastBlock.offsetWidth / 2 - arrowEl.offsetWidth / 2;
                    arrowEl.style.left = `${arrowOffset}px`;
                } else {
                    arrowEl.classList.add('hidden');
                }
            });
        }
        
        // --- LÓGICA DE CONTROLE E AÇÕES ---

        function handleButtonClick(dataset) {
            const { tName, action } = dataset;
            const t = state.transactions.find(tr => tr.name === tName);
            const amount = getTransferAmount();

            const actions = {
                start: () => { 
                    t.reset(); 
                    t.state = T_State.ACTIVE; 
                    log(`${t.name} iniciada.`);
                    logOperation(t, 'START');
                },
                commit: () => {
                    if (state.simMode === SimMode.DIRTY_READ && t.name === 'T1') {
                         state.dataItems['Conta C'].value = state.dataItems['Conta C'].tempValue;
                    }
                    logOperation(t, 'COMMIT');
                    releaseLocks(t);
                    t.state = T_State.COMMITTED; 
                    log(`${t.name} commitada.`, 'green'); 
                },
                abort: () => abortTransaction(t, true),
                transfer: () => initiateTransfer(t),
                // Lost Update
                read: () => {
                    t.localValue = (state.simMode === SimMode.DIRTY_READ) ? state.dataItems['Conta C'].tempValue : state.dataItems['Conta C'].value;
                    if(state.simMode === SimMode.DIRTY_READ) log(`${t.name} leu o saldo "sujo" da Conta C: R$ ${t.localValue.toFixed(2)}`, t.color);
                    else log(`${t.name} leu o saldo da Conta C: R$ ${t.localValue.toFixed(2)}`, t.color);
                    logOperation(t, 'READ', 'C');
                },
                deposit: () => {
                    if(amount === null) return;
                    log(`${t.name} calculou novo saldo: R$ ${(t.localValue + amount).toFixed(2)} e escreveu.`, t.color);
                    state.dataItems['Conta C'].value = t.localValue + amount;
                    t.localValue = null;
                    logOperation(t, 'WRITE', 'C');
                },
                // Dirty Read
                update_no_commit: () => {
                     if(amount === null) return;
                     state.dataItems['Conta C'].tempValue -= amount;
                     log(`${t.name} atualizou Saldo C para ${state.dataItems['Conta C'].tempValue.toFixed(2)} (não commitado)`, t.color);
                     logOperation(t, 'UPDATE', 'C');
                },
                // Unrepeatable Read
                read1: () => {
                    t.localValue = state.dataItems['Conta C'].value;
                    log(`${t.name} (1ª Leitura) Saldo C é: R$ ${t.localValue.toFixed(2)}`, t.color);
                    logOperation(t, 'READ', 'C');
                },
                read2: () => {
                    const currentValue = state.dataItems['Conta C'].value;
                    log(`${t.name} (2ª Leitura) Saldo C é: R$ ${currentValue.toFixed(2)}`, t.color);
                     if (currentValue !== t.localValue) {
                        t.hasError = true;
                        log(`ERRO DE LEITURA NÃO-REPETÍVEL! Valor mudou de R$ ${t.localValue.toFixed(2)} para R$ ${currentValue.toFixed(2)}`, 'red');
                    }
                    logOperation(t, 'READ', 'C');
                },
                update_commit: () => {
                    if(amount === null) return;
                    state.dataItems['Conta C'].value -= amount;
                    log(`${t.name} atualizou e commitou Saldo C para ${state.dataItems['Conta C'].value.toFixed(2)}`, t.color);
                    logOperation(t, 'UPDATE', 'C');
                    logOperation(t, 'COMMIT');
                    t.state = T_State.COMMITTED;
                },
                // Phantom Read
                count1: () => {
                    t.localValue = Object.values(state.dataItems).filter(item => item.value > 450).length;
                    log(`${t.name} (1ª Contagem) encontrou ${t.localValue} clientes ricos.`, t.color);
                    logOperation(t, 'QUERY', '>450');
                },
                count2: () => {
                    const currentCount = Object.values(state.dataItems).filter(item => item.value > 450).length;
                    log(`${t.name} (2ª Contagem) encontrou ${currentCount} clientes ricos.`, t.color);
                    if (currentCount !== t.localValue) {
                        t.hasError = true;
                        log(`ERRO DE LEITURA FANTASMA! A contagem mudou de ${t.localValue} para ${currentCount}.`, 'red');
                    }
                    logOperation(t, 'QUERY', '>450');
                },
                make_rich_commit: () => {
                    if (state.dataItems['Conta P'].value <= 450) {
                        state.dataItems['Conta P'].value = 600; // Torna a conta 'rica'
                        log(`${t.name} tornou a Conta P 'rica' (saldo R$ 600.00) e commitou.`, t.color);
                        logOperation(t, 'UPDATE', 'P');
                        logOperation(t, 'COMMIT');
                        t.state = T_State.COMMITTED;
                    } else {
                        log(`${t.name} não fez nada pois Conta P já é 'rica'.`, t.color);
                    }
                }
            };
            
            if (actions[action]) actions[action]();
            renderAll();
        }
        
        function getTransferAmount() {
            const input = document.getElementById('transfer-amount');
            const amount = parseFloat(input.value);
            if(isNaN(amount) || amount <= 0) {
                log("Valor inválido para a operação.", 'red');
                return null;
            }
            return amount;
        }

        function log(message, color = 'black') {
            const timestamp = new Date().toLocaleTimeString('pt-BR');
            state.logMessages.unshift({ text: `[${timestamp}] ${message}`, color });
            if(state.logMessages.length > 50) state.logMessages.pop();
            renderLog();
        }

        function logOperation(transaction, opType, details = '') {
            transaction.history.push({ type: opType, details });
            renderPipelines();
        }
        
        function showDeadlockAlert() {
            const alertEl = document.getElementById('deadlock-alert');
            alertEl.classList.remove('hidden', 'opacity-0', '-translate-y-20');
            
            setTimeout(() => {
                alertEl.classList.add('opacity-0', '-translate-y-20');
                setTimeout(() => alertEl.classList.add('hidden'), 500);
            }, 4000);
        }

        function resetSimulation(fullReset = true) {
            const alertEl = document.getElementById('deadlock-alert');
            alertEl.classList.add('hidden', 'opacity-0', '-translate-y-20');

            if (fullReset) log("--- Simulador Resetado ---", "purple");
            
            clearInterval(state.deadlockCheckInterval);
            clearInterval(state.mainUpdateInterval);
            if(state.simMode === SimMode.LOCKING) {
                state.mainUpdateInterval = setInterval(update, 500);
                state.deadlockCheckInterval = setInterval(detectAndResolveDeadlock, 2000);
            }
            state.transactions.forEach(t => t.reset());
            for (const name in state.initialValues) {
                state.dataItems[name].value = state.initialValues[name];
                state.dataItems[name].tempValue = state.initialValues[name];
                state.dataItems[name].lockType = null;
                state.dataItems[name].holders.clear();
            }
            if (fullReset) {
                 state.logMessages = [];
                 log("Simulador iniciado. Escolha um modo de simulação.", "purple");
            }
            renderAll();
        }

        function abortTransaction(t, byUser = false) {
             if (byUser) {
                log(`${t.name} abortada pelo usuário.`, 'red');
             }
             if (state.simMode === SimMode.DIRTY_READ && t.name === 'T1') {
                const originalValue = state.dataItems['Conta C'].value;
                const dirtyValue = state.dataItems['Conta C'].tempValue;
                state.dataItems['Conta C'].tempValue = originalValue; // Reverte o valor temporário

                const t2 = state.transactions.find(tr => tr.name === 'T2');
                if (t2.localValue !== null && t2.localValue === dirtyValue) {
                    t2.hasError = true;
                    log(`ERRO DE LEITURA SUJA! T2 leu R$ ${t2.localValue.toFixed(2)}, mas o valor foi revertido para R$ ${originalValue.toFixed(2)}.`, 'red');
                }
             }
             logOperation(t, 'ABORT');
             releaseLocks(t); 
             t.reset(); 
             renderAll();
        }
        
        // --- LÓGICA DE LOCKS ---

        function initiateTransfer(t) {
            const amount = getTransferAmount();
            if(amount === null) return;

            const [fromAcc, toAcc] = (t.name === 'T1') ? ['Conta C', 'Conta P'] : ['Conta P', 'Conta C'];
            
            if(state.dataItems[fromAcc].value < amount) {
                log(`Saldo insuficiente em ${fromAcc} para transferir R$${amount.toFixed(2)}.`, 'red');
                return;
            }

            log(`${t.name} inicia transf. R$${amount.toFixed(2)} de ${fromAcc} para ${toAcc}`, t.color);
            t.pendingOp = { step: 'step2', fromAcc, toAcc, amount };
        }

        function update() {
            let hasChanges = false;
            state.transactions.forEach(t => {
                if(t.state === T_State.ACTIVE && t.pendingOp) {
                    const { step, fromAcc, toAcc, amount } = t.pendingOp;

                    if(step === 'step2' && !t.locksHeld[fromAcc]) {
                        requestLock(t, fromAcc, LockType.EXCLUSIVE);
                        hasChanges = true;
                    } else if(step === 'step2' && t.locksHeld[fromAcc]) {
                        t.pendingOp.step = 'execute';
                        requestLock(t, toAcc, LockType.EXCLUSIVE);
                        hasChanges = true;
                    } else if(step === 'execute' && t.locksHeld[fromAcc] && t.locksHeld[toAcc]) {
                        log(`${t.name} obteve todos os locks. Executando transferência.`, 'green');
                        state.dataItems[fromAcc].value -= amount;
                        state.dataItems[toAcc].value += amount;
                        t.pendingOp = null;
                        hasChanges = true;
                    }
                }
            });
            if (hasChanges) {
                renderAll();
            }
        }
        
        function requestLock(transaction, itemName, lockType) {
            if (state.simMode !== SimMode.LOCKING) return;
            const item = state.dataItems[itemName];

            logOperation(transaction, 'WRITE', itemName.slice(-1));

            const currentLock = transaction.locksHeld[itemName];
            if (currentLock === LockType.EXCLUSIVE) return;

            if (item.lockType === null || (item.lockType === LockType.SHARED && item.holders.size === 1 && item.holders.has(transaction))) {
                grantLock(transaction, item, LockType.EXCLUSIVE);
                return;
            }
            
            log(`Conflito! ${transaction.name} esperando por ${itemName}`, 'orange');
            logOperation(transaction, 'WAIT', itemName.slice(-1));
            transaction.state = T_State.WAITING;
            transaction.waitingFor = { item, lockType };
            renderAll();
        }
        
        function grantLock(transaction, item, lockType) {
            log(`Lock ${lockType} em ${item.name} concedido a ${transaction.name}`, transaction.color);
            logOperation(transaction, 'LOCK', `${lockType.slice(0,1)}(${item.name.slice(-1)})`);

            item.holders.add(transaction);
            transaction.locksHeld[item.name] = lockType;
            item.lockType = LockType.EXCLUSIVE;
            
            if (transaction.state === T_State.WAITING) {
                transaction.state = T_State.ACTIVE;
                transaction.waitingFor = null;
            }
            renderAll();
        }

        function releaseLocks(transaction) {
            if (state.simMode !== SimMode.LOCKING) return;
            
            Object.keys(transaction.locksHeld).forEach(itemName => {
                const item = state.dataItems[itemName];
                item.holders.delete(transaction);
                if (item.holders.size === 0) {
                    item.lockType = null;
                }
            });
            transaction.locksHeld = {};
            // Acordar transações em espera
            state.transactions.forEach(t => checkWaitingTransactions(t));
        }

        function checkWaitingTransactions(t) {
            if (t.state === T_State.WAITING && t.waitingFor) {
                 log(`Reavaliando ${t.name} para ${t.waitingFor.item.name}`, 'black');
                 t.state = T_State.ACTIVE; 
            }
        }

        function detectAndResolveDeadlock() {
            const waitsFor = {};
            const waitingTransactions = state.transactions.filter(t => t.state === T_State.WAITING);
            
            if (waitingTransactions.length < 2) return;

            waitingTransactions.forEach(t => {
                if (t.waitingFor && t.waitingFor.item.holders.size > 0) {
                    waitsFor[t.name] = Array.from(t.waitingFor.item.holders).map(h => h.name);
                }
            });

            for (const startNode of Object.keys(waitsFor)) {
                const path = [startNode];
                const toVisit = [...(waitsFor[startNode] || [])];

                while(toVisit.length > 0) {
                    const currentNode = toVisit.pop();
                    if (path.includes(currentNode)) continue;
                    path.push(currentNode);

                    if (currentNode === startNode) { // CICLO ENCONTRADO!
                        showDeadlockAlert();
                        
                        const victimName = path.sort().pop();
                        const victim = state.transactions.find(t => t.name === victimName);

                        log(`DEADLOCK: Ciclo de espera: ${path.join(' -> ')} -> ${startNode}`, 'red');
                        log(`Estratégia: Abortar a transação com maior nome no ciclo.`, 'purple');
                        log(`Resolvendo... Abortando ${victim.name} (vítima).`, 'red');
                        
                        abortTransaction(victim, false);
                        return;
                    }

                    const nextNodes = waitsFor[currentNode] || [];
                    toVisit.push(...nextNodes);
                }
            }
        }

        // --- INICIALIZAÇÃO DA APLICAÇÃO ---
        init();
    });
    </script>

</body>
</html>

